{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "cross-env NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "cross-env NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@tanstack/react-query": "^5.60.5",
    "axios": "^1.10.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "cross-env": "^7.0.3",
    "date-fns": "^3.6.0",
    "docx": "^8.5.0",
    "dotenv": "^16.4.5",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "file-saver": "^2.0.5",
    "form-data": "^4.0.0",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "memorystore": "^1.6.7",
    "multer": "^1.4.5-lts.1",
    "nanoid": "^5.1.5",
    "next-themes": "^0.4.6",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pdf-lib": "^1.17.1",
    "pdf-parse": "^1.1.1",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "sharp": "^0.33.4",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tesseract.js": "^5.1.0",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.2.7",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "^4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/fs-extra": "^11.0.4",
    "@types/multer": "^1.4.11",
    "@types/node": "^20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/pdf-parse": "^1.1.4",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/sharp": "^0.32.0",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.19"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}
```

**Step 2: Replace your `convert.ts`**

This code uses a hybrid approach. It uses iLovePDF for Word/PDF/Image conversions and local libraries for Text-to-PDF and OCR, matching all the options in your app's UI.


```typescript
import express, { Request, Response } from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { PDFDocument, StandardFonts } from 'pdf-lib';
import { Document, Packer, Paragraph, TextRun } from 'docx';
import Tesseract from 'tesseract.js';
import axios from 'axios';
import FormData from 'form-data';
import dotenv from 'dotenv';
import sharp from 'sharp';
import pdf from 'pdf-parse';

// Load environment variables from .env file
dotenv.config();

// --- CONFIGURATION ---
const ILOVEPDF_API_KEY = process.env.ILOVEPDF_API_KEY;

const router = express.Router();
const upload = multer({ dest: 'uploads/' });

if (!fs.existsSync('uploads')) {
  fs.mkdirSync('uploads');
}

// --- UTILITY FUNCTIONS ---

async function withRetry<T>(fn: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {
  try {
    return await fn();
  } catch (err) {
    if (retries <= 0) throw err;
    console.log(`Retrying... attempts left: ${retries}`);
    await new Promise(res => setTimeout(res, delay));
    return withRetry(fn, retries - 1, delay * 2);
  }
}

function validateFileType(file: Express.Multer.File, allowedTypes: string[]) {
  const ext = path.extname(file.originalname).toLowerCase().slice(1);
  if (!allowedTypes.includes(ext)) {
    throw new Error(`Unsupported file type: .${ext}. Allowed types: ${allowedTypes.join(', ')}`);
  }
}

function wrapText(text: string, font: any, fontSize: number, maxWidth: number): string[] {
    const words = text.split(' ');
    if (words.length === 0) return [' '];
    const lines: string[] = [];
    let currentLine = words[0];
    for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const width = font.widthOfTextAtSize(currentLine + ' ' + word, fontSize);
        if (width < maxWidth) {
            currentLine += ' ' + word;
        } else {
            lines.push(currentLine);
            currentLine = word;
        }
    }
    lines.push(currentLine);
    return lines;
}

// --- CORE CONVERSION LOGIC ---

async function convertWithILovePDF(inputPath: string, tool: string, outputFilename: string): Promise<string> {
  if (!ILOVEPDF_API_KEY) {
    throw new Error('iLovePDF API key is not configured. Please set the ILOVEPDF_API_KEY environment variable on your server.');
  }

  return withRetry(async () => {
    try {
      const startRes = await axios.post(`https://api.ilovepdf.com/v1/start/${tool}`, {}, { headers: { Authorization: `Bearer ${ILOVEPDF_API_KEY}` } });
      const { server, task } = startRes.data;
      const form = new FormData();
      form.append('task', task);
      form.append('file', fs.createReadStream(inputPath));
      await axios.post(`https://${server}/v1/upload`, form, { headers: { ...form.getHeaders(), Authorization: `Bearer ${ILOVEPDF_API_KEY}` } });
      await axios.post(`https://${server}/v1/process`, { task, tool }, { headers: { Authorization: `Bearer ${ILOVEPDF_API_KEY}` } });
      const downloadRes = await axios.get(`https://${server}/v1/download/${task}`, { responseType: 'stream', headers: { Authorization: `Bearer ${ILOVEPDF_API_KEY}` } });
      const outputPath = path.join('uploads', outputFilename);
      const writer = fs.createWriteStream(outputPath);
      downloadRes.data.pipe(writer);
      return new Promise<string>((resolve, reject) => {
        writer.on('finish', () => resolve(outputPath));
        writer.on('error', reject);
      });
    } catch (err: any) {
      if (err.response?.status === 401) throw new Error('Invalid iLovePDF API key.');
      throw new Error(err.response?.data?.error?.message || err.message);
    }
  });
}

async function textToDocx(text: string): Promise<Buffer> {
  const doc = new Document({ sections: [{ children: text.split('\n').map(line => new Paragraph({ children: [new TextRun(line || ' ')] })) }] });
  return Packer.toBuffer(doc);
}

async function textToPdf(text: string): Promise<Uint8Array> {
    const pdfDoc = await PDFDocument.create();
    let page = pdfDoc.addPage([595.28, 841.89]);
    const { width, height } = page.getSize();
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontSize = 12;
    const margin = 50;
    const maxWidth = width - 2 * margin;
    let y = height - margin;
    for (const line of text.split('\n')) {
        const wrappedLines = wrapText(line, font, fontSize, maxWidth);
        for (const wrapped of wrappedLines) {
            if (y < margin) {
                page = pdfDoc.addPage([595.28, 841.89]);
                y = height - margin;
            }
            page.drawText(wrapped, { x: margin, y, font, size: fontSize });
            y -= fontSize + 4;
        }
    }
    return pdfDoc.save();
}

async function extractTextFromPdf(filePath: string): Promise<string> {
    const dataBuffer = fs.readFileSync(filePath);
    const data = await pdf(dataBuffer);
    return data.text;
}

// --- API ENDPOINT ---

router.post('/api/convert', upload.single('file'), async (req: Request, res: Response) => {
  const inputFile = req.file;
  if (!inputFile) return res.status(400).json({ message: 'No file uploaded.' });

  let tempConvertedPath: string | null = null;
  try {
    const { conversionType, targetFormat } = req.body;
    let resultBuffer: Buffer | Uint8Array;
    let resultMime = 'application/octet-stream';
    let resultFilename = `${path.parse(inputFile.originalname).name}_converted.${targetFormat}`;

    switch (conversionType) {
        case 'word-to-pdf':
            validateFileType(inputFile, ['doc', 'docx', 'odt']);
            tempConvertedPath = await convertWithILovePDF(inputFile.path, 'wordpdf', resultFilename);
            resultBuffer = fs.readFileSync(tempConvertedPath);
            resultMime = 'application/pdf';
            break;

        case 'pdf-to-word':
            validateFileType(inputFile, ['pdf']);
            tempConvertedPath = await convertWithILovePDF(inputFile.path, 'pdfword', resultFilename);
            resultBuffer = fs.readFileSync(tempConvertedPath);
            resultMime = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
            break;
            
        case 'pdf-to-text':
            validateFileType(inputFile, ['pdf']);
            const extractedText = await extractTextFromPdf(inputFile.path);
            resultBuffer = Buffer.from(extractedText, 'utf-8');
            resultMime = 'text/plain';
            resultFilename = `${path.parse(inputFile.originalname).name}_extracted.txt`;
            break;

        case 'image-to-pdf':
            validateFileType(inputFile, ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff']);
            tempConvertedPath = await convertWithILovePDF(inputFile.path, 'imagepdf', resultFilename);
            resultBuffer = fs.readFileSync(tempConvertedPath);
            resultMime = 'application/pdf';
            break;

        case 'text-to-pdf':
            validateFileType(inputFile, ['txt']);
            const textContent = fs.readFileSync(inputFile.path, 'utf-8');
            resultBuffer = await textToPdf(textContent);
            resultMime = 'application/pdf';
            break;

        case 'ocr-extract':
            validateFileType(inputFile, ['png', 'jpg', 'jpeg', 'bmp']);
            const processedImageBuffer = await sharp(inputFile.path).grayscale().toBuffer();
            const { data: { text } } = await Tesseract.recognize(processedImageBuffer, 'eng');
            if (targetFormat === 'docx') {
                resultBuffer = await textToDocx(text);
                resultMime = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
            } else {
                resultBuffer = Buffer.from(text, 'utf-8');
                resultMime = 'text/plain';
                resultFilename = `${path.parse(inputFile.originalname).name}_extracted.txt`;
            }
            break;

        default:
            return res.status(400).json({ message: `Unsupported conversion type: ${conversionType}` });
    }

    res.setHeader('Content-Type', resultMime);
    res.setHeader('Content-Disposition', `attachment; filename="${resultFilename}"`);
    res.send(resultBuffer);

  } catch (err: any) {
    console.error('Conversion failed:', err);
    res.status(500).json({ message: 'Conversion failed', error: err.message });
  } finally {
    if (inputFile && fs.existsSync(inputFile.path)) fs.unlinkSync(inputFile.path);
    if (tempConvertedPath && fs.existsSync(tempConvertedPath)) fs.unlinkSync(tempConvertedPath);
  }
});

export default router;
```

**Step 3: Set API Key on Render**

This is the most important step.

1.  Go to your project's dashboard on the Render website.
2.  Click the **Environment** tab.
3.  Click **"Add Environment Variable"**.
4.  In the **Key** field, type `ILOVEPDF_API_KEY`.
5.  In the **Value** field, paste your **Public Key** from the iLovePDF developer website.
6.  Save the changes and deploy your application again.

After these three steps, your application will be fixed. I am confident this will resolve all the issu
